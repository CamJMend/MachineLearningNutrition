# -*- coding: utf-8 -*-
"""A01174422_preparaciondatos.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1C92v9BJ3JNsAUIqQNXNdhivKbdm1Oxdf

# **Modelos predictivos para datos de Nutrición**

**Objetivo del proyecto**

Hacer un análisis de patrones alimenticios y la relación de los mismos con los niveles de energía en mi día a día. Esto se logrará a través de modelos de predicción de la energía que se espera tener tras el consumo de ciertos nutrientes.

**1. Importar las librerías a utilizar**
"""

import pandas as pd
import matplotlib.pyplot as plt
import numpy as np
from matplotlib.colors import ListedColormap
from sklearn import datasets
from sklearn import datasets
from sklearn.model_selection import cross_val_score
from sklearn.model_selection import train_test_split
from sklearn import svm, datasets
from sklearn import linear_model
import seaborn as sns
from numpy.ma.core import sqrt
from google.colab import files
from numpy.ma.core import log10

"""**2. Leer el archivo que contiene los datos**

Este archivo se encuentra dentro del google colab, y cuenta con datos de nutrientes, alimentos, y una columna que nos indica cuanta energía sentía en una escala del 1 al 10 tras consumir los mismos.
"""

df = pd.read_csv('DatosNutri.csv')
df

"""**3. Definir las dimensiones del dataframe**"""

print(df.shape)
print(df.columns)

"""Dimensiones: (45, 7)

**4. Obtener el tipo de datos contenidos en el dataframe**
"""

print(df.info())

"""**5. Cambiar los datos de tipo object por string**"""

obj_columns = df.select_dtypes(include=np.object).columns.tolist()
df[obj_columns] = df[obj_columns].astype('string')
print(df.info())

"""**6. Determinar la cantidad de información ausente**"""

print(df.isna().sum())
print(df.isna().sum()/len(df)*100)

"""**7. Creación de un nuevo dataframe que contenga los datos a utilizar**"""

df2 = df.loc[:,['Calorias (kcal)','Carbohidratos (g)','Lípidos (g)','Proteína (g)','Sodio (g)','Energía']]
df2

"""**8. Normalización del este nuevo data frame**"""

df2 = df2/df2.max()
print(df2)
print(df2.max())

"""**9. Correlación entre atributos**"""

fig = plt.figure(figsize=(8,4))
sns.heatmap(df2.corr(),annot=True, linewidth=0.5, cmap = 'crest')
plt.show()

"""Debido a que este proyecto se enfoca en la relación del nivel de energía y el consumo de diferentes nutrientes, debemos obtener el nutriente con el cual la Energía presenta una mayor relación. En este caso, usaremos la Proteína pues presenta una relación del 40% con la Energía, mayor a la presentada por los otros nutrientes.

**10. Creación de diagrama de dispersión**

Relacionando Energía y Proteína
"""

sns.jointplot(data=df2, x='Proteína (g)',y='Energía', kind='scatter',palette='Set2', height = 4)
plt.show()

"""**11. Creación de histogramas para ambos parámetros**"""

max = df['Energía'].max()
min = df['Energía'].min()
num_datos = df['Energía'].count();
rango = max-min;
clasesfloat = round(1 + 3.332*log10(num_datos));
clases = int(clasesfloat)
fig = plt.figure(figsize=(8,4))
sns.histplot(data=df2, x='Energía',bins=clases,fill=True)
plt.xlabel('Energía')
plt.ylabel('Frecuencias')
plt.show()

"""Podemos observar que es más común tener niveles de energía medio altos tras el consumo de alimentos"""

max = df['Proteína (g)'].max()
min = df['Proteína (g)'].min()
num_datos = df['Proteína (g)'].count();
rango = max-min;
clasesfloat = round(1 + 3.332*log10(num_datos));
clases = int(clasesfloat)
fig = plt.figure(figsize=(8,4))
sns.histplot(data=df2, x='Proteína (g)',bins=clases,fill=True)
plt.xlabel('Proteína (g)')
plt.ylabel('Proteína (g)')
plt.show()

"""Esta gráfica nos muestra que dentro de mi alimentación el consumo de proteína tiende a ser mínimo

**11. Creación del modelo de regresión lineal simple**

Para las variables de Energía y Proteína
"""

#===============================================================================
# GENERAMOS LOS SUBCONJUNTOS DE PRUEBA (test) Y ENTRENAMIENTO (train).
#===============================================================================
# PRIMERO GENERAMOS ARREGLOS DE NUMPY A PARTIR DEL DATA FRAME
X = df2.loc[:,['Proteína (g)']].to_numpy()
print(type(X))
print('DIMENSION DEL CONJUNTO X ', np.shape(X))
y = df2.loc[:,['Energía']].to_numpy()
print(type(y))
print('DIMENSION DEL TARGET ', np.shape(y))
# USAMOS SCIKIT-LEARN PARA GENERAR LOS SUBCONJUNTOS DE PRUEBA Y ENTRENAMIENTO
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=65)

#===============================================================================
# ENTRENAMOS EL ALGORITMO DE REGRESION LINEAL
#===============================================================================
# CARGAMOS EL ALGORITMO Y LO LLAMAMOS ''linreg''
linreg = linear_model.LinearRegression()
# ENTRENAMOS EL ALGORITMO CON EL CONJUNTO DE ENTRENAMIENTO E IMPRIMIMOS SUS
# COEFICIENTES
linreg.fit(X_train,y_train)
print('Pendiente de la regresión a = ', linreg.coef_)
print('Intercepción c = ', linreg.intercept_)

"""**Ecuación del modelo:**

= 0.218 (Proteína) + 0.6036

Considerando los datos normalizados, esta ecuación nos da una tendencia en la que se relacionan la Energía y la Proteína permitiendonos crear predicciones del nivel de energía resultante tras el consumo de cierta cantidad de proteína.
"""

#===============================================================================
# EVALUAMOS LA EFICIENCIA DEL ALGORITMO
#===============================================================================
# HACEMOS UNA PREDICCION USANDO EL CONJUNTO DE PRUEBA
y_pred = linreg.predict(X_test)
# EVALUAMOS LA EFICIENCIA DEL ALGORITMO
score = linreg.score(X_test,y_test)
print('Correlacion/score = ', score,'--Cercano a 1 es mejor--')
# ALTERNATIVAMENTE PODEMOS EVALUAR LA DESVIACIÓN ESTANDAR DEL MODELO LINEAL
Sr = np.sum( (y_pred-y_test)**2 ) # SUMA DE CUADRADOS
n = y_test.shape[0]               # GRADOS DE LIBERTAD
sigma = sqrt(Sr/(n-2))            # DESVIACION ESTANDAR
print('Error cuadrado absoluto Sr = ', Sr)
print('Desviación estándar = ',sigma)

"""De acuerdo a la correlación (0.18) podemos decir que este modelo se encuentra bastante alejado a la realidad, así mismo existe una desviación posible de la predicción de un 26% que a mi parecer es elevado para un modelo de predicción, y también tiene un porcentaje de error del 47% lo cual no lo hace un modelo aceptado.

**12. Gráfica del modelo de regresión lineal vs los datos**
"""

fig = plt.figure(figsize=(6,3))
plt.scatter(X_test,y_test,color='m',label='datos_prueba')
plt.scatter(X_train,y_train,color='g',label='datos_entrenamiento')
y_pred = linreg.predict(X)
plt.plot(X,y_pred,color='b',linewidth=3,label='regresion')
plt.xlabel('Proteína (g)')
plt.ylabel('Energía')
plt.legend()
plt.show()

"""Podemos observar en la gráfica que los datos estan muy dispersos, y es por esto que podemos deducir que este modelo tiene un error significativo con respecto a los datos reales.

**13. Creación del modelo de regresión lineal multiple**
"""

#===============================================================================
# GENERAMOS LOS SUBCONJUNTOS DE PRUEBA (test) Y ENTRENAMIENTO (train).
#===============================================================================
X = df.loc[:,['Calorias (kcal)','Carbohidratos (g)','Lípidos (g)','Proteína (g)','Sodio (g)']].to_numpy()
print(type(X))
print(np.shape(X))
y = df.loc[:,['Energía']].to_numpy()
print(type(y))
print(np.shape(y))
#===============================================================================
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=65)

#===============================================================================
# ENTRENAMOS EL ALGORITMO DE REGRESION LINEAL
#===============================================================================
# CARGAMOS EL ALGORITMO Y LO LLAMAMOS ''linreg''
linreg = linear_model.LinearRegression()
# ENTRENAMOS EL ALGORITMO CON EL CONJUNTO DE ENTRENAMIENTO E IMPRIMIMOS SUS
# COEFICIENTES
linreg.fit(X_train,y_train)
print('Pendiente de la regresión a = ', linreg.coef_)
print('Intercepción c = ', linreg.intercept_)

"""**Ecuación del modelo:**

= -0.76(Calorias) + 0.089(Carbohidratos) + 0.68(Lípidos) + 0.337(Proteína) - 0.075(Sodio) + 0.632

Considerando los datos normalizados esta ecuación nos ayudará a hacer predicciones sobre el nivel de energía tras consumir un alimento, pero tomando en cuenta todos los nutrientes de la base de datos.
"""

#===============================================================================
# EVALUAMOS LA EFICIENCIA DEL ALGORITMO
#===============================================================================
# HACEMOS UNA PREDICCION USANDO EL CONJUNTO DE PRUEBA
y_pred = linreg.predict(X_test)
# EVALUAMOS LA EFICIENCIA DEL ALGORITMO
score = linreg.score(X_test,y_test)
print('Correlacion/score = ', score,'--Cercano a 1 es mejor--')
# ALTERNATIVAMENTE PODEMOS EVALUAR LA DESVIACIÓN ESTANDAR DEL MODELO LINEAL
Sr = np.sum( (y_pred-y_test)**2 ) # SUMA DE CUADRADOS
n = y_test.shape[0]               # GRADOS DE LIBERTAD
sigma = sqrt(Sr/(n-2))            # DESVIACION ESTANDAR
print('Error cuadrado absoluto Sr = ', Sr)
print('Desviación estándar = ',sigma)

"""Este modelo, a diferencia de la regresión lineal simple, tiene una correlación de los datos de 0.31 por lo que es más correcto pensar en hacer un predicción real con este modelo. Por otro lado, también hubo un descenso en el error cuadrdo absoluto y en la desviación estándar, por lo que este modelo nos arrojará predicciónes más acertadas de acuerdo a los datos brindados.

**12. Gráfica del modelo de regresión lineal multiple**
"""

fig = plt.figure(figsize=(6,3))
plt.scatter(range(len(y_test)), y_test,color='m',label='datos')
plt.scatter(range(len(y_pred)), y_pred,color='b',label='prediccion')
plt.legend()
plt.xlabel('indice de los datos')
plt.ylabel('y_test, y_pred')
plt.show()

"""En esta gráfica podemos observar una comparación de los datos reales y los generados a partir del modelo de regresión lineal multiple desarrollado. Podemos observar que, a diferencia del modelo de regresion simple, las predicciones creadas no se encuentran tan dispersas con respecto a los datos reales.

###**Conclusión**###

Tras realizar ambos modelos de predicción se analizó que un modelo de regresion lineal multiple siempre tendrá más veracidad cuando se trata con bases de datos donde la columna a predecir depende de más de 1 variable, puesto a que se tomaran en cuenta todas la variable y se ajustaran los datos.

Para la realización de este proyecto la variable dependiente es el nivel de energía, y si esta solo se relaciona en un modelo con 1 sola variable disminuirá su veracidad, por lo que fue necesaria la creación del modelo de regresión lineal multiple. A pesar de haber hecho uso de este modelo, aún existe una gran entrada al error dentro del mismo, es por esto que podemos asumir que si tuvieramos una base de datos más extensa este modelo tendría un mejor ajuste y podría llegar a existir una mayor correlación entre las variables.
"""